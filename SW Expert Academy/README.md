### # 1859
-> 처음에는 재귀를 이용하여 각 날에 물건을 사는 경우, 안 사는 경우 모두를 체크하여 이익의 최대를 찾도록 구현하였다. 하지만 시간 초과가 나서 다른 풀이 방법을 찾아야했다. <br>
-> 매매가를 뒤에서부터 보면서 지금까지 본 값 중 제일 큰 값이면 이 날 물건을 파는 날이므로 max를 갱신하고, 그렇지 않으면 물건을 사는 날로 보고 현재 최대값에서 그 날의 매매가를 뺀 값을 현재 이익에 더해준다.
<br>

### # 1204
-> 1000개의 점수를 입력받고 그 중 개수가 제일 많은 점수를 출력하는 문제이다. search를 좀 더 빠르게 하기 위해 HashMap을 이용하여 구현하였고 100개의 score 중 학생 수가 제일 많은 점수를 출력하였다. <br>
-> 하지만 다른 사람들의 풀이를 보니 HashMap을 쓰지 않고 그냥 배열로도 풀 수 있었다. 점수는 0 이상 100 이하이기 때문에 크기가 101개인 배열을 선언한다. index를 score로 보고 해당 index 안의 값을 학생 수로 하여 1000개의 점수를 입력받고, 배열을 처음부터 보면서 학생 수가 제일 많은 점수를 출력하도록 구현할 수도 있었다.
<br>

### # 1206
-> 처음에 입력받을 때 앞의 5개 중 최대값이 있는 index를 찾아 maxIndex에 넣어주었다. 그리고 현재 위치의 빌딩 높이가 왼쪽 2칸, 오른쪽 2칸 중 제일 큰 값이면 조망권이 확보되므로 현재 빌딩 높이에서 범위 내의 빌딩 높이를 뺀 값 중 제일 작은 값으로 count해준다. <br>
-> 범위 내에서 제일 높은 빌딩인지를 가지고 있기 위해 확보된 조망권을 계산하기 전, max값을 update해주었다. 새로 범위내로 들어온 빌딩의 높이가 제일 크다면 그 빌딩의 index로 update해주고, 현재 가지고 있던 max가 범위에서 벗어난다면 현재 범위에 들어온 빌딩 중 max값을 다시 찾아준다.
<br>


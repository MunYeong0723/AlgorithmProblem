### # 1859
-> 처음에는 재귀를 이용하여 각 날에 물건을 사는 경우, 안 사는 경우 모두를 체크하여 이익의 최대를 찾도록 구현하였다. 하지만 시간 초과가 나서 다른 풀이 방법을 찾아야했다. <br>
-> 매매가를 뒤에서부터 보면서 지금까지 본 값 중 제일 큰 값이면 이 날 물건을 파는 날이므로 max를 갱신하고, 그렇지 않으면 물건을 사는 날로 보고 현재 최대값에서 그 날의 매매가를 뺀 값을 현재 이익에 더해준다.
<br>

### # 1204
-> 1000개의 점수를 입력받고 그 중 개수가 제일 많은 점수를 출력하는 문제이다. search를 좀 더 빠르게 하기 위해 HashMap을 이용하여 구현하였고 100개의 score 중 학생 수가 제일 많은 점수를 출력하였다. <br>
-> 하지만 다른 사람들의 풀이를 보니 HashMap을 쓰지 않고 그냥 배열로도 풀 수 있었다. 점수는 0 이상 100 이하이기 때문에 크기가 101개인 배열을 선언한다. index를 score로 보고 해당 index 안의 값을 학생 수로 하여 1000개의 점수를 입력받고, 배열을 처음부터 보면서 학생 수가 제일 많은 점수를 출력하도록 구현할 수도 있었다.
<br>
